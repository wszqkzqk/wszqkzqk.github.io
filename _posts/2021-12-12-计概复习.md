---
layout:     post
title:      计概复习
subtitle:   ZQKCHO
date:       2021-07-11
author:     星外之神
header-img: img/bg-sunrise.jpg
catalog:    true
tags:       计概
--- 

下午就要考试了，现在做个这个，麻了😅😅😅

## 要点
1.充分审题、思考后再写
2.注意常见的思考方式：递归简化问题等
3.注意数据类型：int? float? str? 不要在基础问题上搞错
4.注意思维严谨性，如是否考虑0、1等特殊数据，是否在逻辑上正确等等
5.注意数据边界、范围到底应该是多少
## 化学式原子计数(替换成占位符避免重复搜索)
不要会了字典就忘了双列表
元素可能重的时候双列表很有用
一个小技巧：
遍历括号时前面未闭合的括号对后面有干扰的时候可以在使用一次后将用过的括号**替换成"@"等占位符**
另外：
注意思维的严谨性!!!!!!!!括号不一定是平行排列的，还可能有**嵌套**！！！
```python
s = input()
fml = []
i = 0
while i < len(s):    #将字符串分割成括号、元素符号、数字组成的列表
    if 'A' <= s[i] <= 'Z':
        word = s[i]
        while i + 1 < len(s):
            i += 1
            if 'a' <= s[i] <= 'z':
                word += s[i]
            else:
                break
        fml.append(word)
    elif '0' <= s[i] <= '9':
        num = ''
        while i < len(s) and '0' <= s[i] <= '9':
            num += s[i]
            i += 1
        fml.append(num)
    elif s[i] == '[':
        fml.append('(')
        i += 1
    elif s[i] == ']':
        fml.append(')')
        i += 1
    else:
        fml.append(s[i])
        i += 1
dic = {}
eletab = []
indexele = []
basetab = []
for i in range(len(fml)):
    if 'A' <= fml[i] < '[':    #fml[i]是一个元素
        eletab.append(fml[i])
        basetab.append(1)
        indexele.append(i)
    elif '0' <= fml[i] < ':' and fml[i - 1] != ')':    #fml[i]是紧跟元素的数字
        basetab[-1] = int(fml[i])
    elif fml[i] == ')':
        if i + 1 < len(fml):
            if '0' <= fml[i + 1] < ':':    #fml[i]是后面带有数据的右括号
                j = i
                while 1:
                    j -= 1
                    if fml[j] == '(':
                        fml[j] = '@'    #将使用过的左括号变为无意义的占位符"@"
                        break
                for k in range(len(indexele) - 1, -1, -1):
                    if indexele[k] in range(j, i):
                        basetab[k] *= int(fml[i + 1])
for i in range(len(eletab)):
    if eletab[i] not in dic:
        dic[eletab[i]] = basetab[i]
    else:
        dic[eletab[i]] += basetab[i]
for i in dic.items():
    print(*i)
```

## 爬楼梯(递归)
`n级楼梯，每次可以爬1、2、3级，有多少种爬法`

递归思想，n是从(n-1), (n-2), (n-3)爬上来的
```python
n = int(input())
dic ={1:1, 2:2, 3:4}
def steps(n):
    if n in dic:
        return dic[n]
    else:
        dic[n] = (steps(n - 1) + steps(n - 2) + steps(n - 3))%10000
        return dic[n]
print(steps(n)%10000)
```

## 护林员盖房子(边界、开区间的坑)
### 描述
在一片保护林中，护林员想要盖一座房子来居住，但他不能砍伐任何树木。
现在请你帮他计算：保护林中所能用来盖房子的矩形空地的最大面积。
### 输入
输入：
保护林用一个二维矩阵来表示，长宽都不超过20（即<=20）。
第一行是两个正整数m,n，表示矩阵有m行n列。
然后是m行，每行n个整数，用1代表树木，用0表示空地。
### 输出
输出：
一个正整数，表示保护林中能用来盖房子的最大矩形空地面积。
### 样例输入
```
4 5
0 1 0 1 1
0 1 0 0 1
0 0 0 0 0
0 1 1 0 1
```
### 样例输出
```
5
```
### 代码
注意考虑**边界**：range(x, y)是**开区间**，注意**端点**是否应该包括，端点！！！端点！！！端点！！！
    以及注意代入函数的实参在之前设置的到底是多少，有什么**含义**，在后续计算中如何利用等
```python
def check(y, x, mm, nn):
    for j in range(y, mm):
        for k in range(x, nn):
            if woods[j][k] != '0':
                return 0
    a = (mm - y) * (nn - x)
    return a
m, n = map(int, input().split())
woods = []
for i in range(m):
    woods.append(input().split())
house = []
for y in range(m):
    for x in range(n):    #指定了位置(y, x)
        if woods[y][x] == '0':
            for mm in range(y, m):
                for nn in range(x, n):
                    house.append(check(y, x, mm + 1, nn + 1))
print(max(house))
```
## 通配字符匹配(逻辑分析)
### 描述
通配符是一类键盘字符，当我们不知道真正字符或者不想键入完整名字时，常常使用通配符代替一个或多个真正字符。通配符有问号(?)和星号(*)等，其中，“?”可以代替一个字符，而“*”可以代替零个或多个字符。你的任务是，给出一个带有通配符的字符串和一个不带通配符的字符串，判断他们是否能够匹配。
### 输入
输入有两行，每行为一个不超过20个字符的字符串，第一行带通配符，第二行不带通配符
### 输出
如果两者可以匹配，就输出“matched”，否则输出“not matched”
### 代码
注意：想清楚条件判断
    多思考，想清楚问题**本质**后再作答
    对于单独验证的情况的**特殊性**在哪里
    如果'*'不在末尾，则末尾必须为最后的切片，开头同理
    其余条件仅要求各个切片按顺序出现即可
```python
def match(tpstr,compstr):
    for i in range(len(tpstr)):
        if tpstr[i] != compstr[i]:
            if tpstr[i] != '?':
                return(False)
    return(True)
origin = input()
comp = input()
tp = origin.split('*')
ltp = 0
for i in tp:
    ltp += len(i)
if ltp > len(comp):
    print('not matched')
    exit()
if origin[-1] != '*':
    if not match(tp[-1], comp[-len(tp[-1]):]):
        print('not matched')
        exit()
if origin[0] != '*':
    if not match(tp[0], comp[:len(tp[0])]):
        print('not matched')
        exit()
sig = 0    #comp中的位置
for piece in tp:
    if not piece:
        continue
    while sig < len(comp):
        lpiece = len(piece)
        if match(piece, comp[sig:sig + lpiece]):
            sig = sig + lpiece
            break
        else:
            sig = sig + 1
    else:
        print('not matched')
        break
else:
    print('matched')
```

## 放苹果(递归)
### 描述
把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。
### 输入
苹果个数m 和盘子个数n(0<=M，1<=N<=10)
### 输出
不同的放法数目
### 代码
```python
'''
注意：情况考虑仔细——分类讨论是否覆盖完整
    递归注意边界条件
    字典保存结果可以减少不必要运算
'''
dic = {}
def solve(m, n):
    if m == 0 or n == 1 or m == 1:
        return(1)
    elif n > m:
        return(solve(m, m))
    else:
        if (m, n) in dic.keys():
            return(dic[(m,n)])
        else:
            dic[(m, n)] = solve(m - n, n) + solve(m, n - 1)
            return(dic[(m, n)])
m, n = map(int, input().split())
print(solve(m, n))
```

## 数独游戏(dfs算法)
输入一个数独，待解的用“0”表示，求解
```python
"""
这个代码不是我写的
采用了定义函数的方法
可用学习一下
但是先要看懂……😭😭😭😭😭😭
"""
Flag = 0
def dfs(m, n):
    global Flag
    if Flag == 1:
        return
    if arr[m][n] != 0:
        if m == 8 and n == 8:
            for i in range(0, 9):
                for j in range(0, 9):
                    print(arr[i][j], end="")
                print("")
            Flag = 1
            return
        if n == 8:
            dfs(m + 1, 0)
        else:
            dfs(m, n + 1)
    else:
        for i in range(1, 10):
            if x[m][i] == 0 and y[n][i] == 0 and z[m//3*3+n//3+1][i] == 0:
                arr[m][n] = i
                x[m][i] = 1
                y[n][i] = 1
                z[m // 3 * 3 + n // 3 + 1][i] = 1
                if m == 8 and n == 8:
                    for i in range(0, 9):
                        for j in range(0, 9):
                            print(arr[i][j], end="")
                        print("")
                    Flag = 1
                    return
                if n == 8:
                    dfs(m + 1, 0)
                else:
                    dfs(m, n + 1)
                arr[m][n] = 0
                x[m][i] = 0
                y[n][i] = 0
                z[m // 3 * 3 + n // 3 + 1][i] = 0
arr = [[0 for i in range(10)] for j in range(10)]
x = [[0 for i in range(10)] for j in range(10)]
y = [[0 for i in range(10)] for j in range(10)]
z = [[0 for i in range(10)] for j in range(10)]
for i in range(0, 9):
    mid1 = input()
    mid2 = str()
    for m in range(0, 9):
        mid2=mid2+mid1[m]+" "
    arr[i] = mid2.split(" ")
    for j in range(0, 9):
        arr[i][j] = int(arr[i][j])
        if arr[i][j] > 0:
            x[i][arr[i][j]] = 1
            y[j][arr[i][j]] = 1
            z[i//3*3+j//3+1][arr[i][j]] = 1
dfs(0, 0)
```

## 明哥之问(递推)
### 描述
将所有人从1开始编号，第一个人从1开始报数，每次数到m的人被处决，后面的人再从1开始报数…依此循环往复，直到剩下最后一人。
### 输入
两个整数m和k，用逗号分隔。m和k的含义如上
### 输出
一个整数，表示这批待处决的力库一族的余党至少有多少人
### 代码
注意从0开始编号与从1开始编号的区别：可能因此变动的数据较多!!!!!!!!
其实应该统一从0开始编号
```python
m, k = map(int, input().split(','))
i = 0
out = 1
popl = 1
while i != k - 1:
    out = popl
    i = (i + m) % popl
    popl += 1
print(out)
```

## Tim爱读书
### 输入
第一行一个整数n,表示这本书有n页
第二行有n个正整数a1,a2,……,an，其中ai表示要读完第i页的内容要先读完第ai页的内容。（ai>=i）
### 输出
一个正整数，表示读完这本书需要的时间
```python
days = 0
def read(i):
    global days
    readed.add(i)
    if book[i] in readed or book[i] == i:
        days += 1
    else:
        read(book[i])
n = int(input())
book = [int(i)-1 for i in input().split()]
readed = set()
for i in range(n):
    if i not in readed:
        read(i)
print(days)
```