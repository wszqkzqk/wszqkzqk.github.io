---
layout:     post
title:      探索Vala语言
subtitle:   Vala语言学习心得
date:       2022-??-??
author:     星外之神
header-img: img/Vala_Logo.webp
catalog:    true
tags:       GTK Vala 开源软件
---

***未经特殊说明，本文中的所有代码均采用[LGPL v2.1+](https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html)协议公开***

## 简介

Vala语言是一门专门为GObject对象设计的编程语言，语法类似于C#。Vala并没有自己的运行时，而是依靠在编译时由Vala编译器将Vala源代码转化为C源代码，并在此过程中由C语言的基本特性实现lambda、class等各种高级功能，免去了手动用C语言实现这些特性的麻烦。通常来说，基础的Vala程序的依赖仅有GLib和系统的C语言库，十分小巧精炼。Vala还具有自动的内存管理功能，它在编译时进行引用计数，生成的C代码与手动管理内存的C代码结构上类似，避免了引入GC或进行运行时引用计数检查对程序效率的额外开销。因此，Vala同时拥有C#的高开发效率与C的运行高效和低内存占用。

此外，Vala语言与C#语言一样，还具有跨平台的特性。Vala背靠完备的基础库GLib、强大的图形库GTK，以及各种各样的语言绑定，既能用来开发高效率运行的CLI应用，又能用来开发功能丰富的GUI应用，适用场景较广。

附上与Vala相关的重要网站：
* [**Vala Programming Language**](https://vala.dev/)
  * Vala语言官网，包含Vala语言的发布信息与基本介绍
* [**Valadoc.org**](https://valadoc.org/)
  * Vala文档网站，包含了Vala及Vala的语言绑定库的大量文档，对开发与学习很有帮助
* [**GNOME: Projects/Vala/Documentation**](https://wiki.gnome.org/Projects/Vala/Documentation)
  * GNOME官方对Vala文档的汇总
* [**GNOME: Projects/Vala/Tutorial**](https://wiki.gnome.org/Projects/Vala/Tutorial)
  * GNOME官方的Vala教程
* [**Vala Reference Manual**](https://www.vala-project.org/doc/vala/)
  * GNOME官方的Vala语言参考手册
* [**Introducing Vala Programming**](https://link.springer.com/book/10.1007/978-1-4842-5380-9)
  * 实体书，Vala编程介绍
* [**elementary OS: Developer Docs**](https://docs.elementary.io/develop/)
  * elementary OS的开发文档
* [**Meson With Vala**](https://mesonbuild.com/Vala.html)
  * 使用Meson构建系统组织构建Vala程序
* [**Vala For C# Programmers**](https://wiki.gnome.org/Projects/Vala/ValaForCSharpProgrammers)
  * 面向C#程序员的Vala教程
* [**The GTK project**](https://www.gtk.org/)
  * GTK计划官网，内含GTK相关信息、资源、文档，也包含GTK的Vala语言绑定的相关内容
* [**GTK Documentation**](https://docs.gtk.org/)
  * GTK文档网站，内含GTK相关的C语言文档，可供Vala语言开发参考

## 语言特点与代码风格

Vala语言

## 优势

### 语法

### 入门曲线

### 官方库与功能

### Vala Scripts与Unix Shebang

### IDE与LSP支持

## 不足

自Vala语言于2006年推出到现在，始终没有能够发布正式版。该语言虽然开发高效，使用便捷，但是使用人数与开发人数都远远小于主流大众语言。因此，尤其是在一些不太常用的地方，Vala可能会存在一定的编译器Bug。而这些编译器Bug在开发过程中往往难以定位，降低开发效率。Vala语言主要是为了GObject开发，而GObject在Linux下的应用远远多于在Windows下的应用，所以Vala对Windows平台下的开发体验可能顾及较少。

笔者在这里对自己在学习Vala过程中遇到的编译器Bug或反人类之处、不合理之处予以列举。

### 反斜杠灾难：Windows下的编译器Bug

***笔者已向上游提交补丁，该Bug于`0.56.3`修复***

Vala程序支持使用GDB等工具进行调试（需要在编译时向`valac`编译器传递`-g`参数）。Vala编译器依靠在生成的C源代码中插入`#line`语句来加入程序中对应的源代码文件的路径以及行数等调试信息。

然而，在笔者将这一Bug修复前，Vala会将编译参数中的文件路径未加处理即写入到生成的C源代码中。对于Linux等类Unix平台，文件路径的分隔符为`/`，一般不会出现问题。但是Windows平台的文件路径分隔符为`\`，C源代码字符串中的`\`将会被识别为转义字符，这会导致`#line`语句中的源代码文件路径错误，使得调试无法进行；如果在路径中`\`后面存在不可转义的字符，还会在编译的时候大量报错。

### 头文件包含问题：GType的使用与GLib的包含

Vala通常需要依赖GLib与GObject进行使用。默认情况下，任何Vala源代码都看作默认加入了一行`using GLib`，默认使用的基本数据类型（例如：`int`, `uint`, `int64`, `uint64`, `char`, `double`）都是GLib中定义的（对应上文的例子，即`gint`, `guint`, `gint64`, `guint64`, `gchar`, `gdouble`），默认包含的大量内置函数（例如`print`, `get_real_time`）也来自GLib（上文例子对应的是`g_print`, `g_get_real_time`）。甚至，Vala中的Bool值也来自于GLib中宏的定义。

另外，Vala语言本身并没有`#include`语句，Vala在C代码层面对头文件的使用由Vala编译器自动处理。这导致了有时即使没有显式使用GLib中的内容，也存在对GLib头文件的依赖，如果Vala编译器没有在生成的C代码中自动包含所需要的头文件，便会造成编译错误。

例如：
```vala
#/usr/bin/env vala
void main() {
    if (true) {
        stdout.printf("test");
    }
}
```

将这段代码编译，或授予Unix可执行权限执行，会提示以下错误信息：
```bash
/tmp/temptest.vala.XXDIT1.c: In function '_vala_main':
/tmp/temptest.vala.XXDIT1.c:11:13: error: 'TRUE' undeclared (first use in this function)
   11 |         if (TRUE) {
      |             ^~~~
/tmp/temptest.vala.XXDIT1.c:11:13: note: each undeclared identifier is reported only once for each function it appears in
error: cc exited with status 256
Compilation failed: 1 error(s), 0 warning(s)
```

还有更加隐式使用的例子：
```vala
#!/usr/bin/env vala
void main() {
    while (1 == 1) {
        stdout.printf("test\n");
        break;
    }
}
```

同样会出现编译错误：
```bash
/tmp/1.vala.c: In function '_vala_main':
/tmp/1.vala.c:11:16: error: 'TRUE' undeclared (first use in this function)
   11 |         while (TRUE) {
      |                ^~~~
/tmp/1.vala.c:11:16: note: each undeclared identifier is reported only once for each function it appears in
error: cc exited with status 1
Compilation failed: 1 error(s), 0 warning(s)
```

这是因为Vala生成代码中的`TRUE`是在GLib的头文件中定义的，而这段程序没有明显地使用GLib的内容，Vala编译器并没有自动包含GLib的头文件，使得`TRUE`未定义，造成编译失败。

### 容器中对象的运算符问题：`a[i]+=1`、`a[i]=a[i]+1`与`a[i]++`的坑

### 强类型：Gee与GLib中同是返回`uint`的Hash函数类型不兼容

### （个人习惯问题）从C#引入的“不能使用整数代替Bool”的合理性

### 其他问题：产生的C代码的效率问题

## 发展

Vala仍在在积极的发展中，不断有新功能引入。

## 示例
